D:\Desktop\g_api\main.py 
import uvicorn
from fastapi import FastAPI, Body, HTTPException, Depends
from starlette.responses import HTMLResponse
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
import logging
from database.database import SessionLocal, init_db
from database.models import Post, User
from app.model import PostSchema, UserSchema, UserLoginSchema
from app.auth.jwt_handler import signJWT, extract_jwt_username
from app.auth.jwt_bearer import JWTBearer
from sqlalchemy.ext.asyncio import AsyncSession

# Configure the logger
logging.basicConfig(level=logging.INFO,
                    format='%(asctime)s - %(name=s) - %(levelname=s) - %(message=s)',
                    handlers=[
                        logging.FileHandler("app.log"),
                        logging.StreamHandler()
                    ])
logger = logging.getLogger(__name__)

# Create a FastAPI "instance"
app = FastAPI()

# Dependency to get the DB session
async def get_db():
    async with SessionLocal() as session:
        yield session

@app.on_event("startup")
async def on_startup():
    await init_db()

@app.get("/", tags=["test"], response_class=HTMLResponse)
async def root():
    html_content = """
    <html>
    <head>
        <title>Root</title>
    </head>
    <body>
        <h1>Welcome to the Geodata API!</h1>
        <p>This is an HTML representation of the root endpoint.</p>
        <p><a href="/docs">Click here to go to the documentation</a></p>
    </body>
    </html>
    """
    return HTMLResponse(content=html_content)

@app.get("/posts", tags=["posts"])
async def get_posts(db: AsyncSession = Depends(get_db)):
    logger.info("Posts endpoint called")
    result = await db.execute(select(Post))
    posts = result.scalars().all()
    return posts

@app.get("/posts/{id}", tags=["posts"])
async def get_post(id: int, db: AsyncSession = Depends(get_db)):
    logger.info(f"Post/{id} endpoint called")
    result = await db.execute(select(Post).filter(Post.id == id))
    post = result.scalar_one_or_none()
    if post is None:
        raise HTTPException(status_code=404, detail="Post not found")
    return post

@app.get("/error")
async def error_endpoint():
    logger.error("Error endpoint called")
    raise HTTPException(status_code=400, detail="This is a sample error")

@app.post("/posts", dependencies=[Depends(JWTBearer())], tags=["posts"])
async def create_post(post: PostSchema, jwt_token: str = Depends(JWTBearer()), db: AsyncSession = Depends(get_db)):
    # Get the username from the JWT token
    username = extract_jwt_username(jwt_token)

    # Find the user by username
    result = await db.execute(select(User).filter(User.email == username))
    user = result.scalar_one_or_none()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")

    # Create the new post and associate it with the user
    new_post = Post(title=post.title, text=post.text, owner_id=user.id)
    db.add(new_post)
    await db.commit()
    await db.refresh(new_post)

    return {"message": "Post created successfully", "post_id": new_post.id}

@app.post("/user/sign_up", tags=["user"])
async def create_user(user: UserSchema = Body(default=None), db: AsyncSession = Depends(get_db)):
    """
    Registers a new user.
    :param user: The user data.
    :param db: The database session.
    :return: A JWT token for the newly created user.
    """
    logger.info("User sign-up endpoint called for email: %s", user.email)
    new_user = User(email=user.email, password=user.password)
    db.add(new_user)
    await db.commit()
    await db.refresh(new_user)
    
    logger.info(f"User created successfully with email: {user.email}")
    return signJWT(user.email)

async def check_user(data: UserLoginSchema, db: AsyncSession):
    """
    Validates user credentials.
    :param data: The login data.
    :param db: The database session.
    :return: A status indicating whether the credentials are valid.
    """
    result = await db.execute(select(User).filter(User.email == data.email))
    user = result.scalar_one_or_none()
    
    if user:
        if user.password == data.password:
            return {"status": True, "message": "Valid credentials"}
        else:
            return {"status": False, "message": "Invalid password"}
    else:
        return {"status": False, "message": "User does not exist"}

@app.post("/user/login", tags=["user"])
async def user_login(user: UserLoginSchema = Body(...), db: AsyncSession = Depends(get_db)):
    """
    Authenticates a user and returns a JWT token.
    :param user: The login data.
    :param db: The database session.
    :return: A JWT token if the credentials are valid.
    """
    logger.info("User login endpoint called for email: %s", user.email)
    check_result = await check_user(user, db)
    
    if check_result["status"]:
        logger.info("User authenticated successfully: %s", user.email)
        return signJWT(user.email)
    else:
        logger.warning("User authentication failed for email: %s. Reason: %s", user.email, check_result["message"])
        raise HTTPException(status_code=401, detail=check_result["message"])

@app.get("/user/{user_id}/posts", tags=["posts"])
async def get_user_posts(user_id: int, db: AsyncSession = Depends(get_db)):
    """
    Retrieve posts by user ID.
    :param user_id: The ID of the user.
    :param db: The database session.
    :return: A list of posts associated with the user.
    """
    logger.info(f"Fetching posts for user ID: {user_id}")
    
    # Query the database for posts associated with the user ID
    result = await db.execute(select(Post).filter(Post.owner_id == user_id))
    posts = result.scalars().all()
    
    if not posts:
        raise HTTPException(status_code=404, detail="No posts found for this user")
    
    return posts

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)











'''
@app.post("/posts", dependencies=[Depends(JWTBearer())], tags=["posts"])
async def create_post(post: PostSchema, jwt_token: str = Depends(JWTBearer()), db: AsyncSession = Depends(get_db)):
    # Get the username from the JWT token
    username = JWTBearer.extract_jwt_username(jwt_token)

    # Find the user by username
    user = await db.execute(select(User).filter(User.username == username))
    user = user.scalar_one_or_none()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")

    # Create the new post and associate it with the user
    new_post = Post(title=post.title, text=post.text, owner_id=user.id)
    db.add(new_post)
    await db.commit()
    await db.refresh(new_post)

    return {"message": "Post created successfully", "post_id": new_post.id}

@app.post("/user/sign_up", tags=["user"])
async def create_user(user: UserSchema = Body(default=None), db: AsyncSession = Depends(get_db)):
    logger.info("User sign-up endpoint called")
    new_user = User(email=user.email, password=user.password)
    db.add(new_user)
    await db.commit()
    await db.refresh(new_user)
    return signJWT(user.email)

async def check_user(data: UserLoginSchema, db: AsyncSession):
    result = await db.execute(select(User).filter(User.email == data.email))
    user = result.scalar_one_or_none()
    if user:
        if user.password == data.password:
            return {"status": True, "message": "Valid credentials"}
        else:
            return {"status": False, "message": "Invalid password"}
    else:
        return {"status": False, "message": "User does not exist"}

@app.post("/user/login", tags=["user"])
async def user_login(user: UserLoginSchema = Body(...), db: AsyncSession = Depends(get_db)):
    logger.info("User login endpoint called")
    check_result = await check_user(user, db)
    if check_result["status"]:
        return signJWT(user.email)
    else:
        raise HTTPException(status_code=401, detail=check_result["message"])
''' 
D:\Desktop\g_api\main.py 
import uvicorn
from fastapi import FastAPI, Body, HTTPException, Depends
from starlette.responses import HTMLResponse
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
import logging
from database.database import SessionLocal, init_db
from database.models import Post, User
from app.model import PostSchema, UserSchema, UserLoginSchema
from app.auth.jwt_handler import signJWT, extract_jwt_username
from app.auth.jwt_bearer import JWTBearer
from sqlalchemy.ext.asyncio import AsyncSession

# Configure the logger
logging.basicConfig(level=logging.INFO,
                    format='%(asctime)s - %(name=s) - %(levelname=s) - %(message=s)',
                    handlers=[
                        logging.FileHandler("app.log"),
                        logging.StreamHandler()
                    ])
logger = logging.getLogger(__name__)

# Create a FastAPI "instance"
app = FastAPI()

# Dependency to get the DB session
async def get_db():
    async with SessionLocal() as session:
        yield session

@app.on_event("startup")
async def on_startup():
    await init_db()

@app.get("/", tags=["test"], response_class=HTMLResponse)
async def root():
    html_content = """
    <html>
    <head>
        <title>Root</title>
    </head>
    <body>
        <h1>Welcome to the Geodata API!</h1>
        <p>This is an HTML representation of the root endpoint.</p>
        <p><a href="/docs">Click here to go to the documentation</a></p>
    </body>
    </html>
    """
    return HTMLResponse(content=html_content)

@app.get("/posts", tags=["posts"])
async def get_posts(db: AsyncSession = Depends(get_db)):
    logger.info("Posts endpoint called")
    result = await db.execute(select(Post))
    posts = result.scalars().all()
    return posts

@app.get("/posts/{id}", tags=["posts"])
async def get_post(id: int, db: AsyncSession = Depends(get_db)):
    logger.info(f"Post/{id} endpoint called")
    result = await db.execute(select(Post).filter(Post.id == id))
    post = result.scalar_one_or_none()
    if post is None:
        raise HTTPException(status_code=404, detail="Post not found")
    return post

@app.get("/error")
async def error_endpoint():
    logger.error("Error endpoint called")
    raise HTTPException(status_code=400, detail="This is a sample error")

@app.post("/posts", dependencies=[Depends(JWTBearer())], tags=["posts"])
async def create_post(post: PostSchema, jwt_token: str = Depends(JWTBearer()), db: AsyncSession = Depends(get_db)):
    # Get the username from the JWT token
    username = extract_jwt_username(jwt_token)

    # Find the user by username
    result = await db.execute(select(User).filter(User.email == username))
    user = result.scalar_one_or_none()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")

    # Create the new post and associate it with the user
    new_post = Post(title=post.title, text=post.text, owner_id=user.id)
    db.add(new_post)
    await db.commit()
    await db.refresh(new_post)

    return {"message": "Post created successfully", "post_id": new_post.id}

@app.post("/user/sign_up", tags=["user"])
async def create_user(user: UserSchema = Body(default=None), db: AsyncSession = Depends(get_db)):
    """
    Registers a new user.
    :param user: The user data.
    :param db: The database session.
    :return: A JWT token for the newly created user.
    """
    logger.info("User sign-up endpoint called for email: %s", user.email)
    new_user = User(email=user.email, password=user.password)
    db.add(new_user)
    await db.commit()
    await db.refresh(new_user)
    
    logger.info(f"User created successfully with email: {user.email}")
    return signJWT(user.email)

async def check_user(data: UserLoginSchema, db: AsyncSession):
    """
    Validates user credentials.
    :param data: The login data.
    :param db: The database session.
    :return: A status indicating whether the credentials are valid.
    """
    result = await db.execute(select(User).filter(User.email == data.email))
    user = result.scalar_one_or_none()
    
    if user:
        if user.password == data.password:
            return {"status": True, "message": "Valid credentials"}
        else:
            return {"status": False, "message": "Invalid password"}
    else:
        return {"status": False, "message": "User does not exist"}

@app.post("/user/login", tags=["user"])
async def user_login(user: UserLoginSchema = Body(...), db: AsyncSession = Depends(get_db)):
    """
    Authenticates a user and returns a JWT token.
    :param user: The login data.
    :param db: The database session.
    :return: A JWT token if the credentials are valid.
    """
    logger.info("User login endpoint called for email: %s", user.email)
    check_result = await check_user(user, db)
    
    if check_result["status"]:
        logger.info("User authenticated successfully: %s", user.email)
        return signJWT(user.email)
    else:
        logger.warning("User authentication failed for email: %s. Reason: %s", user.email, check_result["message"])
        raise HTTPException(status_code=401, detail=check_result["message"])

@app.get("/user/{user_id}/posts", tags=["posts"])
async def get_user_posts(user_id: int, db: AsyncSession = Depends(get_db)):
    """
    Retrieve posts by user ID.
    :param user_id: The ID of the user.
    :param db: The database session.
    :return: A list of posts associated with the user.
    """
    logger.info(f"Fetching posts for user ID: {user_id}")
    
    # Query the database for posts associated with the user ID
    result = await db.execute(select(Post).filter(Post.owner_id == user_id))
    posts = result.scalars().all()
    
    if not posts:
        raise HTTPException(status_code=404, detail="No posts found for this user")
    
    return posts

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)











'''
@app.post("/posts", dependencies=[Depends(JWTBearer())], tags=["posts"])
async def create_post(post: PostSchema, jwt_token: str = Depends(JWTBearer()), db: AsyncSession = Depends(get_db)):
    # Get the username from the JWT token
    username = JWTBearer.extract_jwt_username(jwt_token)

    # Find the user by username
    user = await db.execute(select(User).filter(User.username == username))
    user = user.scalar_one_or_none()
    if not user:
        raise HTTPException(status_code=404, detail="User not found")

    # Create the new post and associate it with the user
    new_post = Post(title=post.title, text=post.text, owner_id=user.id)
    db.add(new_post)
    await db.commit()
    await db.refresh(new_post)

    return {"message": "Post created successfully", "post_id": new_post.id}

@app.post("/user/sign_up", tags=["user"])
async def create_user(user: UserSchema = Body(default=None), db: AsyncSession = Depends(get_db)):
    logger.info("User sign-up endpoint called")
    new_user = User(email=user.email, password=user.password)
    db.add(new_user)
    await db.commit()
    await db.refresh(new_user)
    return signJWT(user.email)

async def check_user(data: UserLoginSchema, db: AsyncSession):
    result = await db.execute(select(User).filter(User.email == data.email))
    user = result.scalar_one_or_none()
    if user:
        if user.password == data.password:
            return {"status": True, "message": "Valid credentials"}
        else:
            return {"status": False, "message": "Invalid password"}
    else:
        return {"status": False, "message": "User does not exist"}

@app.post("/user/login", tags=["user"])
async def user_login(user: UserLoginSchema = Body(...), db: AsyncSession = Depends(get_db)):
    logger.info("User login endpoint called")
    check_result = await check_user(user, db)
    if check_result["status"]:
        return signJWT(user.email)
    else:
        raise HTTPException(status_code=401, detail=check_result["message"])
''' 
D:\Desktop\g_api\app\config.py 
import os
from dotenv import load_dotenv

load_dotenv()

SECRET_KEY = os.getenv("SECRET")
ALGORITHM = os.getenv("ALGORITHM")
ACCESS_TOKEN_EXPIRE_MINUTES = int(os.getenv("ACCESS_TOKEN_EXPIRE_MINUTES"))
REFRESH_TOKEN_EXPIRE_MINUTES = int(os.getenv("REFRESH_TOKEN_EXPIRE_MINUTES"))
 
D:\Desktop\g_api\app\model.py 
# app/model.py

from pydantic import BaseModel

class PostSchema(BaseModel):
    title: str
    text: str
    
    # No need to include owner_id here since it will be assigned automatically

class UserSchema(BaseModel):
    email: str
    password: str

class UserLoginSchema(BaseModel):
    email: str
    password: str
 
D:\Desktop\g_api\app\auth\jwt_bearer.py 
from fastapi import Request, HTTPException
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from app.auth import jwt_handler

class JWTBearer(HTTPBearer):
    def __init__(self, auto_error: bool = True):
        super(JWTBearer, self).__init__(auto_error=auto_error)

    async def __call__(self, request: Request):
        credentials: HTTPAuthorizationCredentials = await super(JWTBearer, self).__call__(request)
        if credentials:
            if not credentials.scheme == "Bearer":
                raise HTTPException(status_code=403, detail="Invalid authentication scheme.")
            if not self.verify_jwt(credentials.credentials):
                raise HTTPException(status_code=403, detail="Invalid token or expired token.")
            return credentials.credentials
        else:
            raise HTTPException(status_code=403, detail="Invalid authorization code.")

    def verify_jwt(self, jwtoken: str) -> bool:
        is_token_valid: bool = False
        try:
            payload = jwt_handler.decodeJWT(jwtoken)
        except:
            payload = None
        if payload:
            is_token_valid = True
        return is_token_valid
 
D:\Desktop\g_api\app\auth\jwt_handler.py 
import time
from typing import Dict, Union
import jwt
from decouple import config
import logging

# Load environment variables
JWT_SECRET_KEY = config('SECRET', default='secret')
DEBUG = config('DEBUG', default=True, cast=bool)

# Algorithm used to sign the JWT token
JWT_ALGORITHM = 'HS256'

# Logging configuration
logging.basicConfig(level=logging.DEBUG if DEBUG else logging.INFO)
logger = logging.getLogger(__name__)

def signJWT(username: str, expiration: int = 3600) -> str:
    """
    Signs a JWT token with the given username and expiration time.
    :param username: The username to include in the token.
    :param expiration: The expiration time in seconds. Defaults to 3600 seconds (1 hour).
    :return: Encoded JWT token as a string.
    """
    payload = {
        "username": username,
        "exp": time.time() + expiration
    }
    token = jwt.encode(payload, JWT_SECRET_KEY, algorithm=JWT_ALGORITHM)
    logger.debug(f"Generated token for user {username}")
    return token

def decodeJWT(token: str) -> Union[Dict, None]:
    """
    Decodes a JWT token and returns the payload.
    :param token: The JWT token to decode.
    :return: The decoded payload if the token is valid, otherwise an error message.
    """
    try:
        payload = jwt.decode(token, JWT_SECRET_KEY, algorithms=[JWT_ALGORITHM])
        logger.debug(f"Decoded token payload: {payload}")
        return payload
    except jwt.ExpiredSignatureError:
        logger.error("Token has expired")
        return {"error": "Token has expired"}
    except jwt.InvalidTokenError as e:
        logger.error(f"Invalid token: {e}")
        return {"error": "Invalid token"}
    except Exception as e:
        logger.error(f"Error occurred while decoding JWT: {e}")
        return None

def extract_jwt_username(token: str) -> str:
    """
    Extracts the username from a JWT token.
    :param token: The JWT token.
    :return: The username from the token payload.
    """
    payload = decodeJWT(token)
    if "username" in payload:
        return payload["username"]
    return ""
 
D:\Desktop\g_api\database\database.py 
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker, declarative_base

# Update the SQLAlchemy database URL for PostgreSQL
DATABASE_URL = "postgresql+asyncpg://postgres:123@localhost:5432/geodata"

# Create a SQLAlchemy async engine
engine = create_async_engine(DATABASE_URL, echo=True)

# Create a session local class with the async engine
SessionLocal = sessionmaker(bind=engine, class_=AsyncSession, expire_on_commit=False)

# Create a base class for SQLAlchemy models
Base = declarative_base()

async def init_db():
    async with engine.begin() as conn:
        # Reflect existing tables
        existing_tables = await conn.run_sync(Base.metadata.reflect)

        # Check if any tables exist
        if not existing_tables:
            # If no tables exist, create all tables
            await conn.run_sync(Base.metadata.create_all)
        else:
            # If tables exist, continue without dropping and recreating
            print("Database tables already exist. Skipping creation.")
 
D:\Desktop\g_api\database\models.py 
# database/models.py

from sqlalchemy import Column, Integer, String, ForeignKey, Text
from sqlalchemy.orm import relationship
from .database import Base

class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, index=True, nullable=False)
    password = Column(String, nullable=False)
    posts = relationship("Post", back_populates="owner")

class Post(Base):
    __tablename__ = "posts"

    id = Column(Integer, primary_key=True, index=True)
    title = Column(String, index=True, nullable=False)
    text = Column(Text, nullable=False)
    owner_id = Column(Integer, ForeignKey('users.id'), nullable=False)
    owner = relationship("User", back_populates="posts") 
D:\Desktop\g_api\database\__init__.py 
 
